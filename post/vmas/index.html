<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 5.2.0 for Hugo"><meta name=author content="Matteo Bettini"><meta name=description content="VMAS is a vectorized simulator designed for efficient Multi-Agent Reinforcement Learning benchmarking. It is comprised of a vectorized 2D physics engine written in PyTorch and a set of challenging multi-robot scenarios. Additional scenarios can be implemented through a simple and modular interface."><link rel=alternate hreflang=en-us href=https://matteobettini.github.io/post/vmas/><link rel=preconnect href=https://fonts.gstatic.com crossorigin><meta name=theme-color content="#4caf50"><script src=/js/mathjax-config.js></script>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css integrity="sha256-FMvZuGapsJLjouA6k7Eo2lusoAX9i0ShlWFG6qt7SLc=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/github.min.css crossorigin=anonymous title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/dracula.min.css crossorigin=anonymous title=hl-dark media=print onload='this.media="all"' disabled><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.css integrity="sha512-1xoFisiGdy9nvho8EgXuXvnpR5GAMSjFwp40gSRE3NwdUdIMIKuPa7bqoUhLD0O/5tPNhteAsE5XyyMi5reQVA==" crossorigin=anonymous media=print onload='this.media="all"'><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js integrity crossorigin=anonymous async></script>
<link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media=print onload='this.media="all"'><link rel=stylesheet href=/css/wowchemy.08a6e39f78f6b42de9dcc39ef8155d7d.css><link rel=manifest href=/index.webmanifest><link rel=icon type=image/png href=/media/icon_hueab793ca17b85ea7e4569d22d387be97_25680_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_hueab793ca17b85ea7e4569d22d387be97_25680_180x180_fill_lanczos_center_3.png><link rel=canonical href=https://matteobettini.github.io/post/vmas/><meta property="twitter:card" content="summary_large_image"><meta property="og:site_name" content="Matteo Bettini"><meta property="og:url" content="https://matteobettini.github.io/post/vmas/"><meta property="og:title" content="VMAS, Vectorized Multi-Agent Simulator | Matteo Bettini"><meta property="og:description" content="VMAS is a vectorized simulator designed for efficient Multi-Agent Reinforcement Learning benchmarking. It is comprised of a vectorized 2D physics engine written in PyTorch and a set of challenging multi-robot scenarios. Additional scenarios can be implemented through a simple and modular interface."><meta property="og:image" content="https://matteobettini.github.io/post/vmas/featured.png"><meta property="twitter:image" content="https://matteobettini.github.io/post/vmas/featured.png"><meta property="og:locale" content="en-us"><meta property="article:published_time" content="2021-12-05T00:00:00+00:00"><meta property="article:modified_time" content="2021-12-05T00:00:00+00:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://matteobettini.github.io/post/vmas/"},"headline":"VMAS, Vectorized Multi-Agent Simulator","image":["https://matteobettini.github.io/post/vmas/featured.png"],"datePublished":"2021-12-05T00:00:00Z","dateModified":"2021-12-05T00:00:00Z","author":{"@type":"Person","name":"Matteo Bettini"},"publisher":{"@type":"Organization","name":"Matteo Bettini","logo":{"@type":"ImageObject","url":"https://matteobettini.github.io/media/icon_hueab793ca17b85ea7e4569d22d387be97_25680_192x192_fill_lanczos_center_3.png"}},"description":"VMAS is a vectorized simulator designed for efficient Multi-Agent Reinforcement Learning benchmarking. It is comprised of a vectorized 2D physics engine written in PyTorch and a set of challenging multi-robot scenarios. Additional scenarios can be implemented through a simple and modular interface."}</script><title>VMAS, Vectorized Multi-Agent Simulator | Matteo Bettini</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=4374679d307f8097fe028e90ed0e877d><script src=/js/wowchemy-init.min.4be02a3b391999348b0c7478778a0e4b.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class=col-6><h1>Search</h1></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=Close><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box><input name=q id=search-query placeholder=Search... autocapitalize=off autocomplete=off autocorrect=off spellcheck=false type=search class=form-control aria-label=Search...></div></section><section class=section-search-results><div id=search-hits></div></section></div></aside><div class=page-header><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Matteo Bettini</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label="Toggle navigation">
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Matteo Bettini</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/#featured><span>Featured</span></a></li><li class=nav-item><a class=nav-link href=/#publications><span>Publications</span></a></li><li class=nav-item><a class=nav-link href=/#contact><span>Contact</span></a></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=Search><i class="fas fa-search" aria-hidden=true></i></a></li><li class="nav-item dropdown theme-dropdown"><a href=# class=nav-link data-toggle=dropdown aria-haspopup=true aria-label="Display preferences"><i class="fas fa-moon" aria-hidden=true></i></a><div class=dropdown-menu><a href=# class="dropdown-item js-set-theme-light"><span>Light</span></a>
<a href=# class="dropdown-item js-set-theme-dark"><span>Dark</span></a>
<a href=# class="dropdown-item js-set-theme-auto"><span>Automatic</span></a></div></li></ul></div></nav></div><div class=page-body><article class=article><div class="article-container pt-3"><h1>VMAS, Vectorized Multi-Agent Simulator</h1><p class=page-subtitle>VMAS is a vectorized simulator designed for efficient Multi-Agent Reinforcement Learning benchmarking. It is comprised of a vectorized 2D physics engine written in PyTorch and a set of challenging multi-robot scenarios. Additional scenarios can be implemented through a simple and modular interface.</p><div class=article-metadata><div><span class=author-highlighted><a href=/authors/admin/>Matteo Bettini</a></span></div><span class=article-date>Dec 5, 2021</span>
<span class=middot-divider></span>
<span class=article-reading-time>20 min read</span>
<span class=middot-divider></span>
<span class=article-categories><i class="fas fa-folder mr-1"></i><a href=/category/multi-agent-reinforcement-learning/>Multi-Agent Reinforcement Learning</a></span></div><div class="btn-links mb-3"><a class="btn btn-outline-primary btn-page-header" href=https://github.com/proroklab/VectorizedMultiAgentSimulator target=_blank rel=noopener>Code</a>
<a class="btn btn-outline-primary btn-page-header" href=https://colab.research.google.com/github/proroklab/VectorizedMultiAgentSimulator/blob/main/notebooks/VMAS_Use_vmas_environment.ipynb target=_blank rel=noopener>Use in Colab</a>
<a class="btn btn-outline-primary btn-page-header" href=https://colab.research.google.com/github/proroklab/VectorizedMultiAgentSimulator/blob/main/notebooks/VMAS_RLlib.ipynb target=_blank rel=noopener>Train in Colab with RLlib</a></div></div><div class=article-container><div class=article-style><p align=center><img src="https://github.com/matteobettini/vmas-media/blob/main/media/VMAS_scenarios.gif?raw=true" alt=drawing></p><h2 id=welcome-to-vmas>Welcome to VMAS!</h2><p>VMAS is a vectorized framework designed for efficient MARL benchmarking.
It comprises a vectorized 2D physics engine written in PyTorch and a set of challenging multi-robot scenarios.
Scenario creation is made simple and modular to incentivize contributions.
VMAS simulates agents and landmarks of different shapes and supports rotations, elastic collisions, joints, and custom gravity.
Holonomic motion models are used for the agents to simplify simulation. Custom sensors such as LIDARs are available and the simulator supports inter-agent communication.
Vectorization in <a href=https://pytorch.org/ target=_blank rel=noopener>PyTorch</a> allows VMAS to perform simulations in a batch, seamlessly scaling to tens of thousands of parallel environments on accelerated hardware.
VMAS has an interface compatible with <a href=https://github.com/openai/gym target=_blank rel=noopener>OpenAI Gym</a> and with the <a href=https://docs.ray.io/en/latest/rllib/index.html target=_blank rel=noopener>RLlib</a> library, enabling out-of-the-box integration with a wide range of RL algorithms.
The implementation is inspired by <a href=https://github.com/openai/multiagent-particle-envs target=_blank rel=noopener>OpenAI&rsquo;s MPE</a>.
Alongside VMAS&rsquo;s scenarios, we port and vectorize all the scenarios in MPE.</p><h3 id=paperhttpsarxivorgabs220703530><a href=https://arxiv.org/abs/2207.03530 target=_blank rel=noopener>Paper</a></h3><p>The arXiv paper can be found <a href=https://arxiv.org/abs/2207.03530 target=_blank rel=noopener>here</a>.</p><p>If you use VMAS in your research, <strong>cite</strong> it using:</p><pre><code>@article{bettini2022vmas,
  title = {VMAS: A Vectorized Multi-Agent Simulator for Collective Robot Learning},
  author = {Bettini, Matteo and Kortvelesy, Ryan and Blumenkamp, Jan and Prorok, Amanda},
  year = {2022},
  journal={The 16th International Symposium on Distributed Autonomous Robotic Systems},
  publisher={Springer}
}
</code></pre><h3 id=videohttpsyoutubeaadryfiesay><a href=https://youtu.be/aaDRYfiesAY target=_blank rel=noopener>Video</a></h3><p>Watch the presentation video of VMAS, showing its structure, scenarios, and experiments.</p><p align=center><p><a href="https://www.youtube.com/watch?v=aaDRYfiesAY" target=_blank rel=noopener><img src=https://img.youtube.com/vi/aaDRYfiesAY/0.jpg alt="VMAS Video"></a></p></p><h2 id=table-of-contents>Table of contents</h2><ul><li><a href=#vectorizedmultiagentsimulator-vmas>VectorizedMultiAgentSimulator (VMAS)</a><ul><li><a href=#welcome-to-vmas>Welcome to VMAS!</a><ul><li><a href=#paper>Paper</a></li><li><a href=#video>Video</a></li></ul></li><li><a href=#table-of-contents>Table of contents</a></li><li><a href=#how-to-use>How to use</a><ul><li><a href=#notebooks>Notebooks</a></li><li><a href=#install>Install</a></li><li><a href=#run>Run</a><ul><li><a href=#rllib>RLlib</a></li></ul></li></ul></li><li><a href=#simulator-features>Simulator features</a></li><li><a href=#creating-a-new-scenario>Creating a new scenario</a></li><li><a href=#play-a-scenario>Play a scenario</a></li><li><a href=#rendering>Rendering</a><ul><li><a href=#rendering-on-server-machines>Rendering on server machines</a></li></ul></li><li><a href=#list-of-environments>List of environments</a><ul><li><a href=#vmas>VMAS</a><ul><li><a href=#main-scenarios>Main scenarios</a></li><li><a href=#debug-scenarios>Debug scenarios</a></li></ul></li><li><a href=#mpe>MPE</a></li></ul></li><li><a href=#todos>TODOS</a></li></ul></li></ul><h2 id=how-to-use>How to use</h2><h3 id=notebooks>Notebooks</h3><p><a href=https://colab.research.google.com/github/proroklab/VectorizedMultiAgentSimulator/blob/main/notebooks/VMAS_Use_vmas_environment.ipynb target=_blank rel=noopener><img src=https://colab.research.google.com/assets/colab-badge.svg alt="Open In Colab"></a> <strong>Using a VMAS environment</strong>.
Here is a simple notebook that you can run to create, step and render any scenario in VMAS. It reproduces the <code>use_vmas_env.py</code> script in the <code>examples</code> folder.
<a href=https://colab.research.google.com/github/proroklab/VectorizedMultiAgentSimulator/blob/main/notebooks/VMAS_RLlib.ipynb target=_blank rel=noopener><img src=https://colab.research.google.com/assets/colab-badge.svg alt="Open In Colab"></a> <strong>Using VMAS in RLlib</strong>. In this notebook, we show how to use any VMAS scenario in RLlib. It reproduces the <code>rllib.py</code> script in the <code>examples</code> folder.</p><h3 id=install>Install</h3><p>To install the simulator, simply install the requirements using:</p><pre><code>pip install -r requirements.txt
</code></pre><p>and then install the package with:</p><pre><code>pip install -e .
</code></pre><h3 id=run>Run</h3><p>To use the simulator, simply create an environment by passing the name of the scenario
you want (from the <code>scenarios</code> folder) to the <code>make_env</code> function.
The function arguments are explained in the documentation. The function returns an environment
object with the OpenAI gym interface:</p><p>Here is an example:</p><pre><code> env = vmas.make_env(
        scenario_name=&quot;waterfall&quot;,
        num_envs=32,
        device=&quot;cpu&quot;, # Or &quot;cuda&quot; for GPU
        continuous_actions=True,
        wrapper=None,  # One of: None, vmas.Wrapper.RLLIB, and vmas.Wrapper.GYM
        max_steps=None, # Defines the horizon. None is infinite horizon.
        **kwargs # Additional arguments you want to pass to the scenario initialization
    )
</code></pre><p>A further example that you can run is contained in <code>use_vmas_env.py</code> in the <code>examples</code> directory.</p><h4 id=rllib>RLlib</h4><p>To see how to use VMAS in RLlib, check out the script in <code>examples/rllib.py</code>.</p><h2 id=simulator-features>Simulator features</h2><ul><li><strong>Vectorized</strong>: VMAS vectorization can step any number of environments in parallel. This significantly reduces the time needed to collect rollouts for training in MARL.</li><li><strong>Simple</strong>: Complex vectorized physics engines exist (e.g., <a href=https://github.com/google/brax target=_blank rel=noopener>Brax</a>), but they do not scale efficiently when dealing with multiple agents. This defeats the computational speed goal set by vectorization. VMAS uses a simple custom 2D dynamics engine written in PyTorch to provide fast simulation.</li><li><strong>General</strong>: The core of VMAS is structured so that it can be used to implement general high-level multi-robot problems in 2D. It can support adversarial as well as cooperative scenarios. Holonomic point-robot simulation has been chosen to focus on general high-level problems, without learning low-level custom robot controls through MARL.</li><li><strong>Extensible</strong>: VMAS is not just a simulator with a set of environments. It is a framework that can be used to create new multi-agent scenarios in a format that is usable by the whole MARL community. For this purpose, we have modularized the process of creating a task and introduced interactive rendering to debug it. You can define your own scenario in minutes. Have a look at the dedicated section in this document.</li><li><strong>Compatible</strong>: VMAS has wrappers for <a href=https://docs.ray.io/en/latest/rllib/index.html target=_blank rel=noopener>RLlib</a> and <a href=https://github.com/openai/gym target=_blank rel=noopener>OpenAI Gym</a>. RLlib has a large number of already implemented RL algorithms.
Keep in mind that this interface is less efficient than the unwrapped version. For an example of wrapping, see the main of <code>make_env</code>.</li><li><strong>Tested</strong>: Our scenarios come with tests which run a custom designed heuristic on each scenario.</li><li><strong>Entity shapes</strong>: Our entities (agent and landmarks) can have different customizable shapes (spheres, boxes, lines).
All these shapes are supported for elastic collisions.</li><li><strong>Faster than physics engines</strong>: Our simulator is extremely lightweight, using only tensor operations. It is perfect for
running MARL training at scale with multi-agent collisions and interactions.</li><li><strong>Customizable</strong>: When creating a new scenario of your own, the world, agent and landmarks are highly
customizable. Examples are: drag, friction, gravity, simulation timestep, non-differentiable communication, agent sensors (e.g. LIDAR), and masses.</li><li><strong>Non-differentiable communication</strong>: Scenarios can require agents to perform discrete or continuous communication actions.</li><li><strong>Gravity</strong>: VMAS supports customizable gravity.</li><li><strong>Sensors</strong>: Our simulator implements ray casting, which can be used to simulate a wide range of distance-based sensors that can be added to agents. We currently support LIDARs. To see available sensors, have a look at the <code>sensors</code> script.</li><li><strong>Joints</strong>: Our simulator supports joints. Joints are constraints that keep entities at a specified distance. The user can specify the anchor points on the two objects, the distance (including 0), the thickness of the joint, if the joint is allowed to rotate at either anchor point, and if he wants the joint to be collidable. Have a look at the waterfall scenario to see how you can use joints. See the <code>waterfall</code> and <code>joint_passage</code> scenarios for an example.</li><li><strong>Agent actions</strong>: Agents&rsquo; physical actions are 2D forces for holonomic motion. Agent rotation can also be controlled through a torque action (activated by setting <code>agent.action.u_rot_range</code> at agent creation time). Agents can also be equipped with continuous or discrete communication actions.</li><li><strong>Action preprocessing and velocity controller</strong>: By implementing the <code>process_action</code> function of a scenario, you can modify the agents&rsquo; actions before they are passed to the simulator. This can be used to enforce a specific dynamics model (e.g., differential drive). We provide a <code>VelocityController</code> which can be used in this function to treat input actions as velocities (instead of forces). This PID controller takes velocities and outputs the forces which are fed to the simulator. See the <code>vel_control</code> debug scenario for an example.</li></ul><h2 id=creating-a-new-scenario>Creating a new scenario</h2><p>To create a new scenario, just extend the <code>BaseScenario</code> class in <code>scenario.py</code>.</p><p>You will need to implement at least <code>make_world</code>, <code>reset_world_at</code>, <code>observation</code>, and <code>reward</code>. Optionally, you can also implement <code>done</code>, <code>info</code>, <code>process_action</code>, and <code>extra_render</code>.</p><p>You can also change the viewer size, zoom, and enable a background rendered grid by changing these inherited attributes in the <code>make_world</code> function.</p><p>To know how, just read the documentation of <code>BaseScenario</code> in <code>scenario.py</code> and look at the implemented scenarios.</p><h2 id=play-a-scenario>Play a scenario</h2><p>You can play with a scenario interactively! <strong>Just execute its script!</strong></p><p>Just use the <code>render_interactively</code> function in the <code>interactive_rendering.py</code> script. Relevant values will be plotted to screen.
Move the agent with the arrow keys and switch agents with TAB. You can reset the environment by pressing R.
If you have more than 1 agent, you can control another one with W,A,S,D and switch the second agent using LSHIFT. To do this, just set <code>control_two_agents=True</code>.</p><p>On the screen you will see some data from the agent controlled with arrow keys. This data includes: name, current obs,
current reward, total reward so far and environment done flag.</p><p>Here is an overview of what it looks like:</p><p align=center><img src="https://github.com/matteobettini/vmas-media/blob/main/media/interactive.png?raw=true" alt=drawing width=500></p><h2 id=rendering>Rendering</h2><p>To render the environment, just call the <code>render</code> or the <code>try_render_at</code> functions (depending on environment wrapping).</p><p>Example:</p><pre><code>env.render(
    mode=&quot;rgb_array&quot;, # &quot;rgb_array&quot; returns image, &quot;human&quot; renders in display
    agent_index_focus=4, # If None keep all agents in camera, else focus camera on specific agent
    index=0, # Index of batched environment to render
    visualize_when_rgb: bool = False, # Also run human visualization when mode==&quot;rgb_array&quot;
    plot_position_function=None, # A function to plot under the rendering. This function takes the position (x,y) as input and outputs a transparency alpha value. This can be used to visualize a value function.
)
</code></pre><p>You can also change the viewer size, zoom, and enable a background rendered grid by changing these inherited attributes in the scenario <code>make_world</code> function.</p><table><thead><tr><th style=text-align:center>Gif</th><th style=text-align:center>Agent focus</th></tr></thead><tbody><tr><td style=text-align:center><img src="https://github.com/matteobettini/vmas-media/blob/main/media/vmas_simple.gif?raw=true" alt=drawing width=260></td><td style=text-align:center>With <code>agent_index_focus=None</code> the camera keeps focus on all agents</td></tr><tr><td style=text-align:center><img src="https://github.com/matteobettini/vmas-media/blob/main/media/vmas_simple_focus_agent_0.gif?raw=true" alt=drawing width=260></td><td style=text-align:center>With <code>agent_index_focus=0</code> the camera follows agent 0</td></tr><tr><td style=text-align:center><img src="https://github.com/matteobettini/vmas-media/blob/main/media/vmas_simple_focus_agent_4.gif?raw=true" alt=drawing width=260></td><td style=text-align:center>With <code>agent_index_focus=4</code> the camera follows agent 4</td></tr></tbody></table><h3 id=rendering-on-server-machines>Rendering on server machines</h3><p>To render in machines without a display use <code>mode="rgb_array"</code>. Make sure you have OpenGL and Pyglet installed.
To enable rendering on headless machines you should install EGL.
If you do not have EGL, you need to create a fake screen. You can do this by running these commands before the script:</p><pre><code>export DISPLAY=':99.0'
Xvfb :99 -screen 0 1400x900x24 &gt; /dev/null 2&gt;&amp;1 &amp;
</code></pre><p>or in this way:</p><pre><code>xvfb-run -s \&quot;-screen 0 1400x900x24\&quot; python &lt;your_script.py&gt;
</code></pre><p>To create a fake screen you need to have <code>Xvfb</code> installed.</p><h2 id=list-of-environments>List of environments</h2><h3 id=vmas>VMAS</h3><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong><p align=center>dropout</p></strong><br><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/dropout.gif?raw=true"></td><td><strong><p align=center>football</p></strong><br><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/football.gif?raw=true"></td><td><strong><p align=center>transport</p></strong><br><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/transport.gif?raw=true"></td></tr><tr><td><strong><p align=center>wheel</p></strong><br><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/wheel.gif?raw=true"></td><td><strong><p align=center>balance</p></strong><br><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/balance.gif?raw=true"></td><td><strong><p align=center>reverse<br>transport</p></strong><br><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/reverse_transport.gif?raw=true"></td></tr><tr><td><strong><p align=center>give_way</p></strong><br><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/give_way.gif?raw=true"></td><td><strong><p align=center>passage</p></strong><br><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/passage.gif?raw=true"></td><td><strong><p align=center>dispersion</p></strong><br><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/dispersion.gif?raw=true"></td></tr><tr><td><strong><p align=center>joint_passage_size</p></strong><br><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/joint_passage_size.gif?raw=true"></td><td><strong><p align=center>flocking</p></strong><br><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/flocking.gif?raw=true"></td><td><strong><p align=center>discovery</p></strong><br><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/discovery.gif?raw=true"></td></tr><tr><td><strong><p align=center>joint_passage</p></strong><br><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/joint_passage.gif?raw=true"></td><td><strong><p align=center>ball_passage</p></strong><br><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/ball_passage.gif?raw=true"></td><td><strong><p align=center>ball_trajectory</p></strong><br><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/ball_trajectory.gif?raw=true"></td></tr><tr><td><strong><p align=center>buzz_wire</p></strong><br><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/buzz_wire.gif?raw=true"></td><td><strong><p align=center>multi_give_way</p></strong><br><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/multi_give_way.gif?raw=true"></td><td></td></tr></tbody></table><h4 id=main-scenarios>Main scenarios</h4><table><thead><tr><th>Env name</th><th>Description</th><th>GIF</th></tr></thead><tbody><tr><td><code>dropout.py</code></td><td>In this scenario, <code>n_agents</code> and a goal are spawned at random positions between -1 and 1. Agents cannot collide with each other and with the goal. The reward is shared among all agents. The team receives a reward of 1 when at least one agent reaches the goal. A penalty is given to the team proportional to the sum of the magnitude of actions of every agent. This penalises agents for moving. The impact of the energy reward can be tuned by setting <code>energy_coeff</code>. The default coefficient is 0.02 makes it so that for one agent it is always worth reaching the goal. The optimal policy consists in agents sending only the closest agent to the goal and thus saving as much energy as possible. Every agent observes its position, velocity, relative position to the goal and a flag that is set when someone reaches the goal. The environment terminates when when someone reaches the goal. To solve this environment, communication is needed.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/dropout.gif?raw=true" alt=drawing width=90000></td></tr><tr><td><code>dispersion.py</code></td><td>In this scenario, <code>n_agents</code> agents and goals are spawned. All agents spawn in [0,0] and goals spawn at random positions between -1 and 1. Agents cannot collide with each other and with the goals. Agents are tasked with reaching the goals. When a goal is reached, the team gets a reward of 1 if <code>share_reward</code> is true, otherwise the agents which reach that goal in the same step split the reward of 1. If <code>penalise_by_time</code> is true, every agent gets an additional reward of -0.01 at each step. The optimal policy is for agents to disperse and each tackle a different goal. This requires high coordination and diversity. Every agent observes its position and velocity. For every goal it also observes the relative position and a flag indicating if the goal has been already reached by someone or not. The environment terminates when all the goals are reached.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/dispersion.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>transport.py</code></td><td>In this scenario, <code>n_agents</code>, <code>n_packages</code> (default 1) and a goal are spawned at random positions between -1 and 1. Packages are boxes with <code>package_mass</code> mass (default 50 times agent mass) and <code>package_width</code> and <code>package_length</code> as sizes. The goal is for agents to push all packages to the goal. When all packages overlap with the goal, the scenario ends. Each agent receives the same reward which is proportional to the sum of the distance variations between the packages and the goal. In other words, pushing a package towards the goal will give a positive reward, while pushing it away, a negative one. Once a package overlaps with the goal, it becomes green and its contribution to the reward becomes 0. Each agent observes its position, velocity, relative position to packages, package velocities, relative positions between packages and the goal and a flag for each package indicating if it is on the goal. By default packages are very heavy and one agent is barely able to push them. Agents need to collaborate and push packages together to be able to move them faster.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/transport.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>reverse_transport.py</code></td><td>This is exactly the same of transport except with <code>n_agents</code> spawned inside a single package. All the rest is the same.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/reverse_transport.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>give_way.py</code></td><td>In this scenario, two agents and two goals are spawned in a narrow corridor. The agents need to reach the goal with their color. The agents are standing in front of each other&rsquo;s goal and thus need to swap places. In the middle of the corridor there is an asymmetric opening which fits one agent only. Therefore the optimal policy is for one agent to give way to the other. This requires heterogeneous behaviour. Each agent observes its position, velocity and the relative position to its goal. The scenario terminates when both agents reach their goals.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/give_way.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>wheel.py</code></td><td>In this scenario, <code>n_agents</code> are spawned at random positions between -1 and 1. One line with <code>line_length</code> and <code>line_mass</code> is spawned in the middle. The line is constrained in the origin and can rotate. The goal of the agents is to make the absolute angular velocity of the line match <code>desired_velocity</code>. Therefore, it is not sufficient for the agents to all push in the extrema of the line, but they need to organize to achieve, and not exceed, the desired velocity. Each agent observes its position, velocity, the current angle of the line module pi, the absolute difference between the current angular velocity of the line and the desired one, and the relative position to the two line extrema. The reward is shared and it is the absolute difference between the current angular velocity of the line and the desired one.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/wheel.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>balance.py</code></td><td>In this scenario, <code>n_agents</code> are spawned uniformly spaced out under a line upon which lies a spherical package of mass <code>package_mass</code>. The team and the line are spawned at a random X position at the bottom of the environment. The environment has vertical gravity. If <code>random_package_pos_on_line</code> is True (default), the relative X position of the package on the line is random. In the top half of the environment a goal is spawned. The agents have to carry the package to the goal. Each agent receives the same reward which is proportional to the distance variation between the package and the goal. In other words, getting the package closer to the goal will give a positive reward, while moving it away, a negative one. The team receives a negative reward of -10 for making the package or the line fall to the floor. The observations for each agent are: its position, velocity, relative position to the package, relative position to the line, relative position between package and goal, package velocity, line velocity, line angular velocity, and line rotation mod pi. The environment is done either when the package or the line fall or when the package touches the goal.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/balance.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>football.py</code></td><td>In this scenario, a team of <code>n_blue_agents</code> play football against a team of <code>n_red_agents</code>. The boolean parameters <code>ai_blue_agents</code> and <code>ai_red_agents</code> specify whether each team is controlled by action inputs or a programmed AI. Consequently, football can be treated as either a cooperative or competitive task. The reward in this scenario can be tuned with <code>dense_reward_ratio</code>, where a value of 0 denotes a fully sparse reward (1 for a goal scored, -1 for a goal conceded), and 1 denotes a fully dense reward (based on the the difference of the &ldquo;attacking value&rdquo; of each team, which considers the distance from the ball to the goal and the presence of open dribbling/shooting lanes to the goal). Every agent observes its position, velocity, relative position to the ball, and relative velocity to the ball. The episode terminates when one team scores a goal.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/football.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>discovery.py</code></td><td>In this scenario, a team of <code>n_agents</code> has to coordinate to cover <code>n_targets</code> targets as quickly as possible while avoiding collisions. A target is considered covered if <code>agents_per_target</code> agents have approached a target at a distance of at least <code>covering_range</code>. After a target is covered, the <code>agents_per_target</code> each receive a reward and the target is respawned to a new random position. Agents receive a penalty if they collide with each other. Every agent observes its position, velocity, LIDAR range measurements to other agents and targets (independently). The episode terminates after a fixed number of time steps.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/discovery.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>flocking.py</code></td><td>In this scenario, a team of <code>n_agents</code> has to flock around a target while staying together and maximising their velocity without colliding with each other and a number of <code>n_obstacles</code> obstacles. Agents are penalized for colliding with each other and with obstacles, and are rewarded for maximising velocity and minimising the span of the flock (cohesion). Every agent observes its position, velocity, and LIDAR range measurements to other agents. The episode terminates after a fixed number of time steps.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/flocking.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>passage.py</code></td><td>In this scenario, a team of 5 robots is spawned in formation at a random location in the bottom part of the environment. A simular formation of goals is spawned at random in the top part. Each robot has to reach its corresponding goal. In the middle of the environment there is a wall with <code>n_passages</code>. Each passage is large enough to fit one robot at a time. Each agent receives a reward which is proportional to the distance variation between itself and the goal. In other words, getting closer to the goal will give a positive reward, while moving it away, a negative one. This reward will be shared in case <code>shared_reward</code> is true. If collisions among robots occur, each robot involved will get a reward of -10. Each agent observes: its position, velocity, relative position to the goal and relative position to the center of each passage. The environment terminates when all the robots reach their goal.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/passage.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>joint_passage_size.py</code></td><td>Here, two robots of different sizes (blue circles),connected by a linkage through two revolute joints, need to cross a passage while keeping the linkage parallel to it and then match the desired goal position (green circles) on the other side. The passage is comprised of a bigger and a smaller gap, which are spawned in a random position and order on the wall, but always at the same distance between each other. The team is spawned in a random order and position on the lower side with the linkage always perpendicular to the passage. The goal is spawned horizontally in a random position on the upper side. Each robot observes its velocity, relative position to each gap, and relative position to the goal center. The robots receive a shaped global reward that guides them to the goal without colliding with the passage.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/joint_passage_size.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>joint_passage.py</code></td><td>This is the same as <code>joint_passage_size.py</code> with the difference that the robots are now physically identical, but the linkage has an asymmetric mass (black circle). The passage is a single gap, positioned randomly on the wall. The agents need to cross it while keeping the linkage perpendicular to the wall and avoiding collisions. The team and the goal are spawned in a random position, order, and rotation on opposite sides of the passage.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/joint_passage.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>ball_passage.py</code></td><td>This is the same as <code>joint_passage.py</code>, except now the agents are not connected by linkages and need to push a ball through the passage. The reward is only dependent on the ball and it&rsquo;s shaped to guide it through the passage.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/ball_passage.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>ball_trajectory.py</code></td><td>This is the same as <code>circle_trajectory.py</code> except the trajectory reward is now dependent on a ball object. Two agents need to drive the ball in a circular trajectory. If <code>joints=True</code> the agents are connected to the ball with linkages.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/ball_trajectory.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>buzz_wire.py</code></td><td>Two agents are connected to a mass through linkages and need to play the <a href=https://en.wikipedia.org/wiki/Wire_loop_game target=_blank rel=noopener>Buzz Wire game</a> in a straight corridor. Be careful not to touch the borders, or the episode ends!</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/buzz_wire.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>multi_give_way.py</code></td><td>Like <code>give_way</code>, but with four agents. This scenario requires high coordination to be solved.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/multi_give_way.gif?raw=true" alt=drawing width=300></td></tr></tbody></table><h4 id=debug-scenarios>Debug scenarios</h4><table><thead><tr><th>Env name</th><th>Description</th><th>GIF</th></tr></thead><tbody><tr><td><code>waterfall.py</code></td><td><code>n_agents</code> agents are spawned in the top of the environment. They are all connected to each other through collidable linkages. The last agent is connected to a box. Each agent is rewarded based on how close it is to the center of the black line at the bottom. Agents have to reach the line and in doing so they might collide with each other and with boxes in the environment.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/waterfall.gif?raw=true" alt=drawing width=5000></td></tr><tr><td><code>asym_joint.py</code></td><td>Two agents are connected by a linkage with an asymmetric mass. The agents are rewarded for bringing the linkage to a vertical position while consuming the least team energy possible.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/asym_joint.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>vel_control.py</code></td><td>Example scenario where three agents have velocity controllers with different acceleration constraints</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/vel_control.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>goal.py</code></td><td>An agent with a velocity controller is spawned at random in the workspace. It is rewarded for moving to a randomly initialised goal while consuming the least energy. The agent observes its velocity and the relative position to the goal.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/goal.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>het_mass.py</code></td><td>Two agents with different masses are spawned randomly in the workspace. They are rewarded for maximising the team maximum speed while minimizing the team energy expenditure. The optimal policy requires the heavy agent to stay still while the light agent moves at maximum speed.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/het_mass.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>line_trajectory.py</code></td><td>One agent is rewarded to move in a line trajectory .</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/line_trajectory.gif?raw=true" alt=drawing width=300></td></tr><tr><td><code>circle_trajectory.py</code></td><td>One agent is rewarded to move in a circle trajectory at the <code>desired_radius</code>.</td><td><img src="https://github.com/matteobettini/vmas-media/blob/main/media/scenarios/circle_trajectory.gif?raw=true" alt=drawing width=300></td></tr></tbody></table><h3 id=mpehttpsgithubcomopenaimultiagent-particle-envs><a href=https://github.com/openai/multiagent-particle-envs target=_blank rel=noopener>MPE</a></h3><table><thead><tr><th>Env name in code (name in paper)</th><th>Communication?</th><th>Competitive?</th><th>Notes</th></tr></thead><tbody><tr><td><code>simple.py</code></td><td>N</td><td>N</td><td>Single agent sees landmark position, rewarded based on how close it gets to landmark. Not a multi-agent environment &ndash; used for debugging policies.</td></tr><tr><td><code>simple_adversary.py</code> (Physical deception)</td><td>N</td><td>Y</td><td>1 adversary (red), N good agents (green), N landmarks (usually N=2). All agents observe position of landmarks and other agents. One landmark is the ‘target landmark’ (colored green). Good agents rewarded based on how close one of them is to the target landmark, but negatively rewarded if the adversary is close to target landmark. Adversary is rewarded based on how close it is to the target, but it doesn’t know which landmark is the target landmark. So good agents have to learn to ‘split up’ and cover all landmarks to deceive the adversary.</td></tr><tr><td><code>simple_crypto.py</code> (Covert communication)</td><td>Y</td><td>Y</td><td>Two good agents (alice and bob), one adversary (eve). Alice must sent a private message to bob over a public channel. Alice and bob are rewarded based on how well bob reconstructs the message, but negatively rewarded if eve can reconstruct the message. Alice and bob have a private key (randomly generated at beginning of each episode), which they must learn to use to encrypt the message.</td></tr><tr><td><code>simple_push.py</code> (Keep-away)</td><td>N</td><td>Y</td><td>1 agent, 1 adversary, 1 landmark. Agent is rewarded based on distance to landmark. Adversary is rewarded if it is close to the landmark, and if the agent is far from the landmark. So the adversary learns to push agent away from the landmark.</td></tr><tr><td><code>simple_reference.py</code></td><td>Y</td><td>N</td><td>2 agents, 3 landmarks of different colors. Each agent wants to get to their target landmark, which is known only by other agent. Reward is collective. So agents have to learn to communicate the goal of the other agent, and navigate to their landmark. This is the same as the simple_speaker_listener scenario where both agents are simultaneous speakers and listeners.</td></tr><tr><td><code>simple_speaker_listener.py</code> (Cooperative communication)</td><td>Y</td><td>N</td><td>Same as simple_reference, except one agent is the ‘speaker’ (gray) that does not move (observes goal of other agent), and other agent is the listener (cannot speak, but must navigate to correct landmark).</td></tr><tr><td><code>simple_spread.py</code> (Cooperative navigation)</td><td>N</td><td>N</td><td>N agents, N landmarks. Agents are rewarded based on how far any agent is from each landmark. Agents are penalized if they collide with other agents. So, agents have to learn to cover all the landmarks while avoiding collisions.</td></tr><tr><td><code>simple_tag.py</code> (Predator-prey)</td><td>N</td><td>Y</td><td>Predator-prey environment. Good agents (green) are faster and want to avoid being hit by adversaries (red). Adversaries are slower and want to hit good agents. Obstacles (large black circles) block the way.</td></tr><tr><td><code>simple_world_comm.py</code></td><td>Y</td><td>Y</td><td>Environment seen in the video accompanying the paper. Same as simple_tag, except (1) there is food (small blue balls) that the good agents are rewarded for being near, (2) we now have ‘forests’ that hide agents inside from being seen from outside; (3) there is a ‘leader adversary” that can see the agents at all times, and can communicate with the other adversaries to help coordinate the chase.</td></tr></tbody></table><h2 id=todos>TODOS</h2><ul><li><input checked disabled type=checkbox> Talk about action preprocessing and velocity controller</li><li><input checked disabled type=checkbox> New envs from joint project with their descriptions</li><li><input disabled type=checkbox> New ens from adversarial project</li><li><input disabled type=checkbox> Custom actions for scenario</li><li><input disabled type=checkbox> Implement 1D camera sensor</li><li><input disabled type=checkbox> Make football heuristic efficient</li><li><input checked disabled type=checkbox> Link video of experiments</li><li><input checked disabled type=checkbox> Add LIDAR section</li><li><input checked disabled type=checkbox> Implement LIDAR</li><li><input checked disabled type=checkbox> Rewrite all MPE scenarios<ul><li><input checked disabled type=checkbox> simple</li><li><input checked disabled type=checkbox> simple_adversary</li><li><input checked disabled type=checkbox> simple_crypto</li><li><input checked disabled type=checkbox> simple_push</li><li><input checked disabled type=checkbox> simple_reference</li><li><input checked disabled type=checkbox> simple_speaker_listener</li><li><input checked disabled type=checkbox> simple_spread</li><li><input checked disabled type=checkbox> simple_tag</li><li><input checked disabled type=checkbox> simple_world_comm</li></ul></li></ul></div><div class=article-tags><a class="badge badge-light" href=/tag/multi-agent-reinforcement-learning/>Multi-Agent Reinforcement Learning</a></div><div class="media author-card content-widget-hr"><a href=https://matteobettini.github.io/><img class="avatar mr-3 avatar-circle" src=/authors/admin/avatar_hud6e8b1feea32bacba9d9483ffbfda6ff_281920_270x270_fill_q100_lanczos_center.JPG alt="Matteo Bettini"></a><div class=media-body><h5 class=card-title><a href=https://matteobettini.github.io/>Matteo Bettini</a></h5><h6 class=card-subtitle>PhD Candidate</h6><p class=card-text>Matteo&rsquo;s research is focused on studying heterogeneity and resilience in multi-agent and multi-robot systems.</p><ul class=network-icon aria-hidden=true><li><a href=/#contact><i class="fas fa-envelope"></i></a></li><li><a href="https://scholar.google.com/citations?user=hcvR_W0AAAAJ" target=_blank rel=noopener><i class="fas fa-graduation-cap"></i></a></li><li><a href=https://github.com/matteobettini target=_blank rel=noopener><i class="fab fa-github"></i></a></li><li><a href=https://linkedin.com/in/bettinimatteo target=_blank rel=noopener><i class="fab fa-linkedin"></i></a></li></ul></div></div><div class="article-widget content-widget-hr"><h3>Related</h3><ul><li><a href=/publication/heterogeneous-multi-robot-reinforcement-learning/>Heterogeneous Multi-Robot Reinforcement Learning</a></li><li><a href=/publication/vmas-a-vectorized-multi-agent-simulator-for-collective-robot-learning/>VMAS: A Vectorized Multi-Agent Simulator for Collective Robot Learning</a></li></ul></div></div></article></div><div class=page-footer><div class=container><footer class=site-footer><p class=powered-by>View <a href=https://github.com/matteobettini/professional_website target=_blank rel=noopener>source</a>.</p></footer></div></div><div id=modal class="modal fade" role=dialog><div class=modal-dialog><div class=modal-content><div class=modal-header><h5 class=modal-title>Cite</h5><button type=button class=close data-dismiss=modal aria-label=Close>
<span aria-hidden=true>&#215;</span></button></div><div class=modal-body><pre><code class="tex hljs"></code></pre></div><div class=modal-footer><a class="btn btn-outline-primary my-1 js-copy-cite" href=# target=_blank><i class="fas fa-copy"></i> Copy</a>
<a class="btn btn-outline-primary my-1 js-download-cite" href=# target=_blank><i class="fas fa-download"></i> Download</a><div id=modal-error></div></div></div></div></div><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.1.0/instantpage.min.js integrity="sha512-1+qUtKoh9XZW7j+6LhRMAyOrgSQKenQ4mluTR+cvxXjP1Z54RxZuzstR/H9kgPXQsVB8IW7DMDFUJpzLjvhGSQ==" crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js integrity="sha512-TDKKr+IvoqZnPzc3l35hdjpHD0m+b2EC2SrLEgKDRWpxf2rFCxemkgvJ5kfU48ip+Y+m2XVKyOCD85ybtlZDmw==" crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/r.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/python.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/latex.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.js integrity="sha512-SeiQaaDh73yrb56sTW/RgVdi/mMqNeM2oBwubFHagc5BkixSpP1fvqF47mKzPGWYSSy4RwbBunrJBQ4Co8fRWA==" crossorigin=anonymous></script>
<script id=search-hit-fuse-template type=text/x-template>
        <div class="search-hit" id="summary-{{key}}">
          <div class="search-hit-content">
            <div class="search-hit-name">
              <a href="{{relpermalink}}">{{title}}</a>
              <div class="article-metadata search-hit-type">{{type}}</div>
              <p class="search-hit-description">{{snippet}}</p>
            </div>
          </div>
        </div>
      </script><script src=https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin=anonymous></script>
<script src=/js/bootstrap.bundle.min.6aed84840afc03ab4d5750157f69c120.js></script>
<script src=/en/js/wowchemy.min.26bc5a5b73c468c9e767656a378ac5e3.js></script>
<script async defer src=https://buttons.github.io/buttons.js></script></body></html>